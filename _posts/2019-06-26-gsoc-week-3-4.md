---
layout: post
title:  "GSoC 2019 | Week 3, 4"
date:   2019-06-26
category: open-source
---

## Introduction

It's 2 more weeks into my GSoC working on [NumRuby](https://github.com/SciRuby/numruby). I worked on adding slicing support and integrate slicing in iterators. Slicing is a crucial feature of a matrix library and must be efficiently implemented as it acts as base for many other operations. So, in order to write an efficient implementation I went through NumPy's resources on slicing and also through their implementation of slicing. After reading resources on slicing, I came up with an implementation which would use indexing to traverse only those elements which are part of slice.

## Slicing

**What is slicing?**

Wikipedia defines slicing as an operation that extracts a subset of elements from an array and packages them as another array, possibly in a different dimension from the original [[source](https://en.wikipedia.org/wiki/Array_slicing)]. For slicing in NMatrix, the definition would be same with "array" replaced with "matrix". To retrieve a single value, you use indexing. Similarly, to retrieve a collection of values, you would use slicing. A slice could be of lesser number of dimensions that the parent matrix or could have the same number of dimensions. 

For example, suppose there is a matrix `nm` having shape `[2, 3, 4]` and there is a slice `x = n[0, 0..1, 0..1]` and another slice `y = n[0..1, 0..1, 0..1]`. `x` would be of shape `[2, 2]` and `y` would be of shape `[2, 2, 2]`. This is because in `x` the length of range along first dimension is just one. So, the number of dimensions of slice is number of dimensions of matrix reduced by the number of one length ranges specified. Slicing is used a lot to get the divide data into parts depending on a parameter type or to get data for some particular value[s] of a parameter. For example, the images below gives a good visualization of how slicing works using the very same application. 

<img src="{{ '/assets/img/data-cubes-8-728.jpg' | prepend: site.baseurl }}" alt="">

<img src="{{ '/assets/img/data-cubes-9-728.jpg' | prepend: site.baseurl }}" alt="">

Images source: [https://www.slideshare.net/algum/data-cubes-7923771](https://www.slideshare.net/algum/data-cubes-7923771)

If we assume Product as first dimension, Location as second dimension and Time as third dimension, then first image shows a slice (in blue color) along a row for which Product is 'Wireless Mouse'. The second image shows a slice (in blue color) along a column for which Location is 'Asia'.

An example on usage of slicing is given below,

```ruby
pry -r './lib/nmatrix.rb'
[1] pry(main)> m = NMatrix.new [2, 4], [1, 2, 3, 4, 5, 6, 7, 8]
=> 
[2] pry(main)> m[0, 0..3].elements  #slice to get first row
=> [1.0, 2.0, 3.0, 4.0]
[3] pry(main)> m[1, 0..3].elements  #slice to get second row
=> [5.0, 6.0, 7.0, 8.0]
[4] pry(main)> m[0..1, 0].elements  #slice to get first column
=> [1.0, 5.0]
[5] pry(main)> m[0..1, 1].elements  #slice to get second column
=> [2.0, 6.0]
[6] pry(main)> m[0..1, 2].elements  #slice to get third column
=> [3.0, 7.0]
[7] pry(main)> m[0..1, 3].elements  #slice to get fourth column
=> [4.0, 8.0]
```

**Implementation of slicing**

## Using slicing in iterators

I implemented iterators for NMatrix during last week. These also included iterators along a dimension such as `each_row`, `each_column` and `each_layer`. These "along the dimension" iterators were only implemented for 2d matrices as they can't be implemented for n-dimensional matrices without slicing.


```ruby
pry -r './lib/nmatrix.rb'
[1] pry(main)> m = NMatrix.new [2, 4], [1, 2, 3, 4, 5, 6, 7, 8]
=> 
[2] pry(main)> m.each_row do |x|
[2] pry(main)*   p x.elements
[2] pry(main)* end  
[1.0, 2.0, 3.0, 4.0]
[5.0, 6.0, 7.0, 8.0]
=> 
```

```ruby
pry -r './lib/nmatrix.rb'
[1] pry(main)> m = NMatrix.new [2, 4], [1, 2, 3, 4, 5, 6, 7, 8]
=> 
[2] pry(main)> m.each_column do |x|
[2] pry(main)*   p x.elements  
[2] pry(main)* end  
[1.0, 5.0]
[2.0, 6.0]
[3.0, 7.0]
[4.0, 8.0]
=> 
```

```ruby
pry -r './lib/nmatrix.rb'
[1] pry(main)> m = NMatrix.new [2, 2, 2], [1, 2, 3, 4, 5, 6, 7, 8]
=> 
[2] pry(main)> m.each_layer do |x|
[2] pry(main)*   p x.elements  
[2] pry(main)* end  
[1.0, 3.0, 5.0, 7.0]
[2.0, 4.0, 6.0, 8.0]
=> 
```

Corresponding pull requests can be found here at [https://github.com/SciRuby/numruby/pull/19](https://github.com/SciRuby/numruby/pull/19) and [https://github.com/SciRuby/numruby/pull/22](https://github.com/SciRuby/numruby/pull/22). 

For coming weeks, I'll complete the above remaining iterators and start work on slicing and broadcasting. Feel free to share your thoughts in the comments section. Thanks for reading.
